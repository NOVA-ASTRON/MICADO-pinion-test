#include "driverdev.h"
#include <iostream>
#include <mutex>
#include <sstream>
#include <string_view>
//#include <syncstream>
#include <thread>
#include <QCoreApplication>
#include <QSerialPortInfo>

#define lock(mut) const std::lock_guard<std::mutex> lock(mut);

static const deviceinfo rs485id             = { .ID = "FT2JDUB8A", .baud = 19200 };
static const deviceinfo autocollimatorid    = { .ID = "FT1IEXMOA", .baud = 9600 };
static const deviceinfo renishaw1id         = { .ID = "48F524753138", .baud = 115200 };
static const deviceinfo renishaw2id         = { .ID = "48EB43743138", .baud = 115200 };
static const deviceinfo motronaid           = { .ID = "FT1IF7NZA", .baud = 38400 };
//static const deviceinfo phytron1id          = { .ID = "6&32A5DFEC&1&3", .baud = 115200 };
static const deviceinfo phytron1id          = { .ID = "5&3B489C26&0&1", .baud = 115200 };
// backup ids:
static const deviceinfo phytron2id          = { .ID = "15F15702", .baud = 115200 };
static const deviceinfo phytron3id          = { .ID = "3B3F6816", .baud = 115200 };
static const deviceinfo phytron4id          = { .ID = "12c8f4c0", .baud = 115200 };

std::map<std::string,const deviceinfo*> deviceInfoLookup = {
    {"rs485",&rs485id},
    {"autocollimator",&autocollimatorid},
    {"renishaw",&renishaw1id},
    {"renishaw2",&renishaw2id},
    {"motrona",&motronaid},
    {"phytron",&phytron1id},
    {"phytron2",&phytron2id},
    {"phytron3",&phytron3id},
    {"phytron4",&phytron4id},
};

const deviceinfo * DeviceInfoFromName(std::string &name){
    if (deviceInfoLookup.count(name))
        return deviceInfoLookup[name];
    return nullptr;
}

DriverDev::DriverDev(QObject *parent):QObject(parent)
{
    //std::lock_guard<std::mutex> lock(_lock);
}


QSerialPort *DriverDev::FindSerialPort(deviceinfo dev)
{
    log->Write("Searching device with ID " + dev.ID);
    QString IDtoFind(dev.ID.c_str());
    const auto infos = QSerialPortInfo::availablePorts();
    for (auto &info:infos){
        std::stringstream ss;
        ss << "serial : "<< info.serialNumber().toStdString() <<"\n";
        ss << "desc : " << info.description().toStdString() <<"\n";
        log->Write(ss.str());
        if (info.serialNumber()==IDtoFind){
           QSerialPort *ret = new QSerialPort(info);

           // if correctly created apply settings
           if (ret) {
               ret->setBaudRate(dev.baud);
           }
           return ret;
        }
    }

    log->Write("Failed to find COM port.");
    return null;
}

bool DriverDev::Connect()
{
    lock (_lock)
    {
        serial = FindSerialPort(myID);

        if (serial == nullptr)
        {
            log->Write("SerialDev: failed to attched serial for " + name);
            return false;
        }
        log->Write("SerialDev: attched serial for " + name);

        if (serial->open(QIODevice::ReadWrite) == false)
        {
            log->Write("SerialDev(" + name + "): failed to open serial port");
            return false;
        } else {
            serial->flush();
        }

        log->Write("SerialDev: outgoing bytes buffer : 0");
        log->Write("SerialDev: incoming bytes buffer : " + QString::number(serial->readBufferSize()).toStdString());
        //log->Write("SerialDev: incoming bytes trigger " + serial.ReceivedBytesThreshold.Tostd::string());
        //log->Write("SerialDev: read time out " + serial.ReadTimeout.Tostd::string());

    }
    return true;
}

void DriverDev::Disconnect()
{
    // grace time for handling incoming data.
    msdelay(500);
    lock (_lock)
    {
        if (serial != nullptr) serial->close();
        serial = nullptr;
    }

}

void DriverDev::InitDriverDev(const deviceinfo *ID, LogFile l, std::string n)
{
    log = l;
    log->Write("Add device " + n);
    myID = *ID;
    name = n;
    valid=Connect();
}

void DriverDev::addHandler()
{
    lock (_lock)
    {
        if (serial)
            connect(serial, &QSerialPort::readyRead,this,&DriverDev::processincomingbytes);
    }
}

void DriverDev::processincomingbytes()
{
    lock (_lock)
    {
        if (serial) {
            IncomingData.append(serial->readAll());
            incomingbytes(IncomingData);
        }
    }
}

bool DriverDev::SendCommand(Command &command, std::string err)
{
    bool retval = false;
    lock (_lock)
    {
        if (serial)
        {
            try
            {
                serial->write(command.cmd,command.length);
                retval = true;
            }
            catch (const std::exception& e)
            {
                log->Write(err);
            }
        }
    }
    if (retval == false)
        log->Write("SerialDev(" + name + ") Not present:" + err);
    return retval;
}

deviceState DriverDev::GetDeviceState()
{
    return {
        .name = name,
        .connected = ((serial != nullptr) ? serial->isOpen() : false)
    };
}

bool DriverDev::getValid() const
{
    return valid;
}

void msdelay(int ms)
{
    QTime dieTime= QTime::currentTime().addMSecs(ms);
    while (QTime::currentTime() < dieTime)
        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);
}

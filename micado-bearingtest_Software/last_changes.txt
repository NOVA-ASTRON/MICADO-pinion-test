diff --git a/linux/analogdaq.cpp b/linux/analogdaq.cpp
index 81cee94..4409d4a 100644
--- a/linux/analogdaq.cpp
+++ b/linux/analogdaq.cpp
@@ -61,12 +61,16 @@ int AnalogDAQ::Setup()
 #endif
     return 1;
 }
+
+int rnd=1020313;
+
 float AnalogDAQ::get_AD(int channel)
 {
+    rnd = (rnd+210730921)^28934234+340785;
     if (channel==0){
-        return 0.0f+(rand()&255)/300.f;
+        return 0.0f+(rnd&255)/300.f;
     }
-    return 100.0f+(rand()&255)/30.f;
+    return 100.0f+(rnd&255)/30.f;
 }
 
 
diff --git a/mainwindow.cpp b/mainwindow.cpp
index 469212e..de702ab 100644
--- a/mainwindow.cpp
+++ b/mainwindow.cpp
@@ -9,7 +9,7 @@
 #include <sstream>
 #include <iomanip>
 
-static int interval=100;
+
 static const int num_samples=200;
 auto last_measurement=std::chrono::high_resolution_clock::now();
 
@@ -26,7 +26,7 @@ MainWindow::MainWindow(QWidget *parent)
 
     ui->setupUi(this);
     chart = new QChart();
-
+    interval=100;
     QDateTime now=QDateTime::currentDateTime();
     for (int i=0;i<num_series;i+=1){
         series[i] = new QLineSeries(chart);
@@ -40,6 +40,8 @@ MainWindow::MainWindow(QWidget *parent)
         }
     }
 
+    curr_queue=0;
+    sample_batch=-1;
 
     //chart->createDefaultAxes();
     chart_axisX = new QDateTimeAxis();
@@ -134,8 +136,14 @@ MainWindow::MainWindow(QWidget *parent)
     // add Torque sensor
     //------------------------------------------------------------------------------------------------
 
-    TorqueSensorAvailable = TorqueSensor.Setup();
+    //TorqueSensorAvailable = TorqueSensor.Setup();
+
 
+    updatesTimer = new QTimer(this);
+    connect(updatesTimer, SIGNAL(timeout()),
+            this, SLOT(on_updates_timer()));
+
+    updatesTimer->start(50);// 20 Hz
 
     //------------------------------------------------------------------------------------------------
     // process data every 0.1 sec
@@ -196,9 +204,16 @@ MainWindow::MainWindow(QWidget *parent)
         camtimer->start(20);
     }
 
+    //------------------------------------------------------------------------------------------------
     ui->label_8->setEnabled(false);
     ui->revolutions_counter->setEnabled(false);
 
+    //------------------------------------------------------------------------------------------------
+    // start background thread
+    //------------------------------------------------------------------------------------------------
+
+    backgroundMeasurements.start();
+
 }
 
 MainWindow::~MainWindow()
@@ -210,67 +225,36 @@ MainWindow::~MainWindow()
 
 void MainWindow::update_monitoring()
 {
-    QDateTime now = QDateTime::currentDateTime();
-    QDateTime from = now.addMSecs(-num_samples*interval);
-    chart_axisX->setRange(from,now);
-    //chart->axisX()->setRange(from.toMSecsSinceEpoch(),now.toMSecsSinceEpoch());
-
-    float temp[4]={0.f,0.f,0.f,0.f};
-
-    for (int samp=0;samp<tcount;samp+=1){
-        for (int i=0;i<num_series;i+=1){
-            while (series[i]->count() >= num_samples)
-                series[i]->removePoints(0,1);
-            *series[i]<<QPointF(measurements[samp].stamp.toMSecsSinceEpoch(),measurements[samp].val[i]);
-            //series[i]->append(now.toMSecsSinceEpoch(), TorqueSensor.get_AD(i));
-            series[i]->pointAdded(1);
-            temp[i]+=measurements[samp].val[i];
-        }
-    }
-    QLCDNumber * ref[]={
-        nullptr,
-        ui->temp_sensor_1_lcdNumber,
-        ui->temp_sensor_2_lcdNumber,
-        ui->temp_sensor_3_lcdNumber,
-    };
-    for (int tsensor=1;tsensor<4;tsensor+=1){
-        ref[tsensor]->display(temp[tsensor]/(float)tcount);
-    }
-    /*
-    if (TorqueSensorAvailable){
-        for (int i=0;i<num_series;i+=1){
-            while (series[i]->count() >= num_samples) series[i]->removePoints(0,1);
-            *series[i]<<QPointF(now.toMSecsSinceEpoch(), TorqueSensor.get_AD(i));
-            //series[i]->append(now.toMSecsSinceEpoch(), TorqueSensor.get_AD(i));
-            series[i]->pointAdded(1);
+     //chart->axisX()->setRange(from.toMSecsSinceEpoch(),now.toMSecsSinceEpoch());
+
+    if (backgroundMeasurements.sample_batch>=0){
+        QDateTime now = QDateTime::currentDateTime();
+        QDateTime from = now.addMSecs(-num_samples*interval);
+        chart_axisX->setRange(from,now);
+        float temp[4]={0.f,0.f,0.f,0.f};
+
+        for (int samp=0;samp<backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch];samp+=1){
+            for (int i=0;i<num_series;i+=1){
+                while (series[i]->count() >= num_samples)
+                    series[i]->removePoints(0,1);
+                *series[i]<<QPointF(backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].stamp/1000000,backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].val[i]);
+                //series[i]->append(now.toMSecsSinceEpoch(), TorqueSensor.get_AD(i));
+                series[i]->pointAdded(1);
+                temp[i]+=backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].val[i];
+            }
         }
-    } else {
-
         QLCDNumber * ref[]={
             nullptr,
             ui->temp_sensor_1_lcdNumber,
             ui->temp_sensor_2_lcdNumber,
             ui->temp_sensor_3_lcdNumber,
         };
-
-        for (int i=0;i<num_series;i+=1){
-            while (series[i]->count() >= num_samples) series[i]->removePoints(0,1);
-            if (i==0){
-                qreal val = 0.0+(rand()&255)/300.f;
-                *series[i]<<QPointF(now.toMSecsSinceEpoch(),val);
-            }
-            else{
-                qreal val =  100.0+(rand()&255)/30.f;
-                *series[i]<<QPointF(now.toMSecsSinceEpoch(),val);
-                ref[i]->display(val);
-            }
-            //series[i]->append(now.toMSecsSinceEpoch(),0.0);
-            series[i]->pointAdded(1);
+        for (int tsensor=1;tsensor<4;tsensor+=1){
+            ref[tsensor]->display(temp[tsensor]/(float)backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch]);
         }
+        backgroundMeasurements.sample_batch=-1;
     }
-    */
-
-    //
+    ui->microseconds_current->setText(QString::number(backgroundMeasurements.avg_usec));
 }
 static int seq=0;
 void MainWindow::update_cam_image()
@@ -325,6 +309,7 @@ void MainWindow::on_start_run_button_clicked()
             delete testbench_log;
             testbench_log=nullptr;
         }
+
         ui->start_run_button->setText("START");
     } else
     if (phytron_log && phytron){
@@ -363,10 +348,17 @@ void MainWindow::on_led_intensity_horizontalSlider_2_valueChanged(int value)
 }
 void MainWindow::on_timer()
 {
+    if (saveImage) {
+        auto time_running = QDateTime::currentSecsSinceEpoch()-vidStartTime.toSecsSinceEpoch();
+        if (time_running>=ui->video_duration_spinBox->value()) {
+            saveImage = false;
+        }
+    }
+    /*
     auto stamp = std::chrono::high_resolution_clock::now();
     auto dtime = stamp-last_measurement;
     last_measurement=stamp;
-    measurements[tcount]={
+    sample curr_sample={
         QDateTime::currentDateTime(),
         TorqueSensor.get_AD(0),
         TorqueSensor.get_AD(1),
@@ -375,34 +367,37 @@ void MainWindow::on_timer()
     };
 
     if (testbench_log)
-        store_measurements(testbench_log);
+        store_measurements(testbench_log,curr_sample);
+
+    measurements[curr_queue][tcount++]=curr_sample;
+
 
 
-    if (saveImage) {
-        auto time_running = QDateTime::currentSecsSinceEpoch()-vidStartTime.toSecsSinceEpoch();
-        if (time_running>=ui->video_duration_spinBox->value()) {
-            saveImage = false;
-        }
-    }
 
     // refresh at max 20 Hz
-    tcount+=1;
-    if ((tcount*interval)>50){
+
+    if ((tcount*interval)>=50){
         auto dt = std::chrono::duration_cast<std::chrono::microseconds>(dtime).count();
         float timetaken = 0.001f*dt;
 
         ui->microseconds_current->setText(QString::number(timetaken));
-        update_monitoring();
+        //update_monitoring();
+
+        // mark this queue as 'done' and allow the monitoring to catch up.
+        batch_size[curr_queue]=tcount;
+        sample_batch = curr_queue;
+
+        curr_queue = (curr_queue+1)&3;
 
 
-        if (testbench_main_state==TEST_FINISHED && testbench_timer && testbench_timer->isActive()){
-            testbench_timer->stop();
-            if (ui->start_run_button->isEnabled()) {
-                ui->start_run_button->setText("Start");
-            }
-        }
         tcount=0;
     }
+    */
+}
+
+void MainWindow::on_updates_timer()
+{
+    update_monitoring();
 }
 
 void MainWindow::on_camera()
@@ -479,19 +474,20 @@ void MainWindow::on_camera_exp_time_spinBox_valueChanged(int arg1)
 
 void MainWindow::on_sampling_time_editingFinished()
 {
-    timer->stop();
-    timer->start(ui->sampling_time->value());
+    //timer->stop();
+
     interval = ui->sampling_time->value();
+    //timer->start(ui->sampling_time->value());
 }
 
-void MainWindow::store_measurements(LogFile  where)
+void MainWindow::store_measurements(LogFile  where,sample & samp)
 {
     if (where){
         std::stringstream ss;
         //for (int i=0;i<4;i+=1)
         // ss << TorqueSensor.get_AD(0) << ",";
         for (int i=0;i<4;i+=1)
-            ss << measurements[tcount].val[i] << ",";
+            ss << samp.val[i] << ",";
 
         //if (phytron)
         //    ss << phytron->GetPos() << ",";
diff --git a/mainwindow.h b/mainwindow.h
index 094b37a..957e014 100644
--- a/mainwindow.h
+++ b/mainwindow.h
@@ -5,6 +5,7 @@
 #include "led_driver.h"
 #include "pythronmotordriver.h"
 #include "thorlabscamera.h"
+#include "threadedtimer.h"
 
 #include <QtCharts>
 #include <QLineSeries>
@@ -16,25 +17,13 @@ namespace Ui { class MainWindow; }
 QT_END_NAMESPACE
 
 
-typedef enum testbench_states_t {
-    TEST_IDLE,
-    TEST_FINISHED,
-    TEST_CW_LONG,
-    TEST_CW_SHORT,
-    TEST_CCW_LONG,
-    TEST_CCW_SHORT,
-    TEST_START_MOVIE_CAPTURE,
-    TEST_SAVE_IMAGE,
-    TEST_WAIT_PHYTRON,
-    TEST_WAIT_TIME,
-
-}testbench_states;
 
+/*
 typedef struct {
     QDateTime stamp;
     qreal val[4];
 } sample;
-
+*/
 const int num_series = 4;
 class MainWindow : public QMainWindow
 {
@@ -54,6 +43,7 @@ private slots:
     void on_led_intensity_horizontalSlider_2_valueChanged(int value);
 
     void on_timer();
+    void on_updates_timer();
     void on_camera();
     void on_testbench_tick();
 
@@ -62,7 +52,7 @@ private slots:
     void on_sampling_time_editingFinished();
 
 private:
-    void store_measurements(LogFile where);
+    void store_measurements(LogFile where, sample &samp);
     Ui::MainWindow *ui;
     QLineSeries *series[num_series];
     QChart *chart;
@@ -84,14 +74,19 @@ private:
     QString imgDir;
     QDateTime vidStartTime;
     int vidCycles;
-    QTimer *timer,*camtimer,*testbench_timer;
+    QTimer *timer,*camtimer,*testbench_timer,*updatesTimer;
+    threadedTimer backgroundMeasurements;
     int testbench_total_num_revs;
     int testbench_waited_ms;
     int testbench_tick_ms;
     volatile bool testbench_stop;
     int tcount;
     LogFile testbench_log;
-    sample measurements[200];
+    volatile int curr_queue,sample_batch;
+    sample measurements[4][200];
+    int batch_size[4];
+
+    int interval;
 
     testbench_states testbench_main_state;
     testbench_states testbench_next_state;
diff --git a/mainwindow.ui b/mainwindow.ui
index 1a66889..15d266a 100644
--- a/mainwindow.ui
+++ b/mainwindow.ui
@@ -767,9 +767,9 @@
     <widget class="QLabel" name="microseconds_current">
      <property name="geometry">
       <rect>
-       <x>1100</x>
+       <x>1060</x>
        <y>420</y>
-       <width>92</width>
+       <width>211</width>
        <height>32</height>
       </rect>
      </property>
diff --git a/micado-bearingtest.pro b/micado-bearingtest.pro
index 1f95a70..16c1d94 100644
--- a/micado-bearingtest.pro
+++ b/micado-bearingtest.pro
@@ -14,7 +14,8 @@ SOURCES += \
     pythronmotordriver.cpp \
     thorlabscamera.cpp \
     thorlabs/tl_camera_sdk_load.c \
-    led_driver.cpp
+    led_driver.cpp \
+    threadedtimer.cpp
 
 
 win32: SOURCES += win11/analogdaq.cpp
@@ -27,7 +28,8 @@ HEADERS += \
     mainwindow.h \
     pythronmotordriver.h \
     thorlabscamera.h \
-    led_driver.h
+    led_driver.h \
+    threadedtimer.h
 
 
 win32: HEADERS += win11/Analog.h win11/Board.h win11/cbw.h win11/analogdaq.h
diff --git a/threadedtimer.cpp b/threadedtimer.cpp
index 7055694..0088f5c 100644
--- a/threadedtimer.cpp
+++ b/threadedtimer.cpp
@@ -1,6 +1,113 @@
+#include <sstream>
 #include "threadedtimer.h"
+#include <chrono>
 
 threadedTimer::threadedTimer()
 {
+    TorqueSensorAvailable = TorqueSensor.Setup();
+    start_log=false;
+    stop_log=false;
+    avg_usec=1;
+    curr_queue=0;
+    sample_batch=-1;
+}
+
+void threadedTimer::unit_of_work()
+{
+    long long stamp = std::chrono::high_resolution_clock::now().time_since_epoch().count();
+    long long dtime = stamp-start_of_measurements;
+
+    long long current_dt = stamp-last_measurement;
+    last_measurement = stamp;
+
+    if (current_dt>1300000){
+        avg_usec = current_dt;
+    }
+
+    total_amount_of_samples++;
+    //avg_usec = dtime/total_amount_of_samples;
+
+    //last_measurement+=1000000;
+    sample curr_sample={
+        last_measurement,
+        TorqueSensor.get_AD(0),
+        TorqueSensor.get_AD(1),
+        TorqueSensor.get_AD(2),
+        TorqueSensor.get_AD(3),
+    };
+
+    if (testbench_log)
+        store_measurements(testbench_log,curr_sample);
+
+    measurements[curr_queue][tcount++]=curr_sample;
+
+
+
+
+    // refresh at max 20 Hz
+
+    if ((tcount)>=40){
+        //auto dt = std::chrono::duration_cast<std::chrono::microseconds>(dtime).count();
+        //float timetaken = 0.001f*dt;
+
+        //ui->microseconds_current->setText(QString::number(timetaken));
+        //update_monitoring();
+
+        // mark this queue as 'done' and allow the monitoring to catch up.
+        batch_size[curr_queue]=tcount;
+        sample_batch = curr_queue;
+
+        curr_queue = (curr_queue+1)&3;
+
+
+        tcount=0;
+        if (start_log) {
+            if (testbench_log){
+                delete testbench_log;
+                testbench_log=new LogFile_t(logdest.toStdString());
+            }
+            start_log=false;
+        }
+        if (stop_log) {
+            if (testbench_log){
+                delete testbench_log;
+                testbench_log=nullptr;
+            }
+            stop_log=false;
+        }
+    }
+}
+
+void threadedTimer::run()
+{
+    localTimer = new QTimer(this);
+    localTimer->setInterval(1);
+    localTimer->connect(localTimer, SIGNAL(timeout()), this, SLOT(unit_of_work()));
+    localTimer->start(1);
+    last_measurement=std::chrono::high_resolution_clock::now().time_since_epoch().count();
+    start_of_measurements=last_measurement;
+    total_amount_of_samples=0;
+    /* Here: */
+    exec();             // Starts Qt event loop and stays there
+    // Which means you can't have a while(true) loop inside doIt()
+    // which instead will get called every 1 ms by your init code above.
+}
+
+void threadedTimer::store_measurements(LogFile where, sample &samp)
+{
+    if (where){
+        std::stringstream ss;
+        //for (int i=0;i<4;i+=1)
+        // ss << TorqueSensor.get_AD(0) << ",";
+        for (int i=0;i<4;i+=1)
+            ss << samp.val[i] << ",";
 
+        //if (phytron)
+        //    ss << phytron->GetPos() << ",";
+        //else
+        //    ss << 0 << ",";
+        ss << (int) testbench_main_state ;
+        ss << "\n";
+        where->Write(ss.str());
+    }
 }
diff --git a/threadedtimer.h b/threadedtimer.h
index 8d372ff..4e402bd 100644
--- a/threadedtimer.h
+++ b/threadedtimer.h
@@ -2,11 +2,62 @@
 #define THREADEDTIMER_H
 
 #include <QObject>
+#include <QThread>
+#include <QTime>
+#include <QTimer>
+#include <analogdaq.h>
+
+#include "logfile.h"
+
+typedef struct {
+    long long stamp;
+    qreal val[4];
+} sample;
+
+typedef enum testbench_states_t {
+    TEST_IDLE,
+    TEST_FINISHED,
+    TEST_CW_LONG,
+    TEST_CW_SHORT,
+    TEST_CCW_LONG,
+    TEST_CCW_SHORT,
+    TEST_START_MOVIE_CAPTURE,
+    TEST_SAVE_IMAGE,
+    TEST_WAIT_PHYTRON,
+    TEST_WAIT_TIME,
+
+}testbench_states;
 
 class threadedTimer : public QThread
 {
+    Q_OBJECT
 public:
     threadedTimer();
+    QTimer * localTimer;
+
+
+    int tcount;
+    LogFile testbench_log;
+    volatile int curr_queue,sample_batch;
+    sample measurements[4][200];
+    int batch_size[4];
+    AnalogDAQ TorqueSensor;
+    bool TorqueSensorAvailable;
+    QString logdest;
+    volatile bool start_log,stop_log;
+    testbench_states testbench_main_state;
+
+    long long avg_usec;
+    long long start_of_measurements;
+    long long total_amount_of_samples;
+    long long last_measurement;
+
+public slots:
+    void unit_of_work();
+protected:
+    void run();
+private:
+    void store_measurements(LogFile  where,sample & samp);
 };
 
-#endif // THREADEDTIMER_H
\ No newline at end of file
+#endif // THREADEDTIMER_H

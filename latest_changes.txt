diff --git a/linux/analogdaq.cpp b/linux/analogdaq.cpp
index 4409d4a..2862e1a 100644
--- a/linux/analogdaq.cpp
+++ b/linux/analogdaq.cpp
@@ -66,7 +66,7 @@ int rnd=1020313;
 
 float AnalogDAQ::get_AD(int channel)
 {
-    rnd = (rnd+210730921)^28934234+340785;
+    rnd = (rnd+210730921)^2893423+340785;
     if (channel==0){
         return 0.0f+(rnd&255)/300.f;
     }
diff --git a/mainwindow.cpp b/mainwindow.cpp
index de702ab..13e5f14 100644
--- a/mainwindow.cpp
+++ b/mainwindow.cpp
@@ -10,7 +10,7 @@
 #include <iomanip>
 
 
-static const int num_samples=200;
+static const int num_samples=100;
 auto last_measurement=std::chrono::high_resolution_clock::now();
 
 
@@ -227,30 +227,73 @@ void MainWindow::update_monitoring()
 {
      //chart->axisX()->setRange(from.toMSecsSinceEpoch(),now.toMSecsSinceEpoch());
 
-    if (backgroundMeasurements.sample_batch>=0){
+    if (backgroundMeasurements.sample_batch>=0) {
         QDateTime now = QDateTime::currentDateTime();
         QDateTime from = now.addMSecs(-num_samples*interval);
         chart_axisX->setRange(from,now);
         float temp[4]={0.f,0.f,0.f,0.f};
+        int start=0;
 
-        for (int samp=0;samp<backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch];samp+=1){
+
+
+        if (backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch]>=num_samples*ui->sampling_time->value())
+            start=backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch]-num_samples*ui->sampling_time->value();
+
+
+        int num_added = 0;
+        int total_samples=backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch];
+
+        sample cumulative_sample=backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][0];
+        for (int samp=start;samp<total_samples;samp+=1){
+
+            if (num_added==0){
+                cumulative_sample=backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp];
+                num_added++;
+            } else {
+                // merge samples
+                if (num_added<ui->sampling_time->value()){
+                    for (int i=0;i<num_series;i+=1)
+                        cumulative_sample.val[i]+=backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].val[i];
+                    num_added++;
+                } else {
+                    for (int i=0;i<num_series;i+=1){
+                        // remove if no room
+                        while (series[i]->count() >= num_samples)
+                            series[i]->removePoints(0,1);
+
+                        // append
+                        *series[i]<<QPointF(cumulative_sample.stamp/1000000,cumulative_sample.val[i]/(qreal)num_added);
+                        //series[i]->append(now.toMSecsSinceEpoch(), TorqueSensor.get_AD(i));
+                        series[i]->pointAdded(1);
+                        temp[i]+=cumulative_sample.val[i];
+                    }
+                    num_added=0;
+                }
+            }
+        }
+        if (num_added>0){
             for (int i=0;i<num_series;i+=1){
+                // remove if no room
                 while (series[i]->count() >= num_samples)
                     series[i]->removePoints(0,1);
-                *series[i]<<QPointF(backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].stamp/1000000,backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].val[i]);
+
+                // append
+                *series[i]<<QPointF(cumulative_sample.stamp/1000000,cumulative_sample.val[i]/(qreal)num_added);
                 //series[i]->append(now.toMSecsSinceEpoch(), TorqueSensor.get_AD(i));
                 series[i]->pointAdded(1);
-                temp[i]+=backgroundMeasurements.measurements[backgroundMeasurements.sample_batch][samp].val[i];
+                temp[i]+=cumulative_sample.val[i];
             }
         }
+
         QLCDNumber * ref[]={
             nullptr,
             ui->temp_sensor_1_lcdNumber,
             ui->temp_sensor_2_lcdNumber,
             ui->temp_sensor_3_lcdNumber,
         };
+
         for (int tsensor=1;tsensor<4;tsensor+=1){
-            ref[tsensor]->display(temp[tsensor]/(float)backgroundMeasurements.batch_size[backgroundMeasurements.sample_batch]);
+            ref[tsensor]->display(temp[tsensor]/(float)(total_samples-start));
         }
         backgroundMeasurements.sample_batch=-1;
     }
diff --git a/threadedtimer.cpp b/threadedtimer.cpp
index 0088f5c..c4295c9 100644
--- a/threadedtimer.cpp
+++ b/threadedtimer.cpp
@@ -14,15 +14,22 @@ threadedTimer::threadedTimer()
 
 void threadedTimer::unit_of_work()
 {
-    long long stamp = std::chrono::high_resolution_clock::now().time_since_epoch().count();
-    long long dtime = stamp-start_of_measurements;
+    uint64_t stamp = std::chrono::duration_cast<std::chrono::nanoseconds>(
+                std::chrono::high_resolution_clock::now().time_since_epoch())
+                .count();
+    //long long stamp = ns;//std::chrono::steady_clock::now().time_since_epoch().count();
+    //uint64_t dtime = stamp-start_of_measurements;
 
-    long long current_dt = stamp-last_measurement;
-    last_measurement = stamp;
+    uint64_t current_dt = stamp-last_measurement;
 
-    if (current_dt>1300000){
-        avg_usec = current_dt;
+
+    if (stamp<start_of_measurements){
+        usleep(10);
+        return;
     }
+    avg_usec = (avg_usec+current_dt)/2;
+    start_of_measurements += 1000000ull;
+    last_measurement=stamp;
 
     total_amount_of_samples++;
     //avg_usec = dtime/total_amount_of_samples;
@@ -46,7 +53,7 @@ void threadedTimer::unit_of_work()
 
     // refresh at max 20 Hz
 
-    if ((tcount)>=40){
+    if ((tcount)>70 && sample_batch==-1){
         //auto dt = std::chrono::duration_cast<std::chrono::microseconds>(dtime).count();
         //float timetaken = 0.001f*dt;
 
@@ -54,13 +61,13 @@ void threadedTimer::unit_of_work()
         //update_monitoring();
 
         // mark this queue as 'done' and allow the monitoring to catch up.
+
         batch_size[curr_queue]=tcount;
         sample_batch = curr_queue;
-
         curr_queue = (curr_queue+1)&3;
 
-
         tcount=0;
+
         if (start_log) {
             if (testbench_log){
                 delete testbench_log;
@@ -75,22 +82,27 @@ void threadedTimer::unit_of_work()
             }
             stop_log=false;
         }
+    } else if (tcount>=799) {
+        tcount = 0;
     }
 }
 
 void threadedTimer::run()
 {
-    localTimer = new QTimer(this);
-    localTimer->setInterval(1);
-    localTimer->connect(localTimer, SIGNAL(timeout()), this, SLOT(unit_of_work()));
-    localTimer->start(1);
+    //localTimer = new QTimer(this);
+    //localTimer->setInterval(1);
+    //localTimer->connect(localTimer, SIGNAL(timeout()), this, SLOT(unit_of_work()));
+    //localTimer->start(1);
     last_measurement=std::chrono::high_resolution_clock::now().time_since_epoch().count();
-    start_of_measurements=last_measurement;
+    start_of_measurements=last_measurement+1000000ll;
     total_amount_of_samples=0;
     /* Here: */
-    exec();             // Starts Qt event loop and stays there
+    //exec();             // Starts Qt event loop and stays there
     // Which means you can't have a while(true) loop inside doIt()
     // which instead will get called every 1 ms by your init code above.
+    while (1){
+        unit_of_work();
+    }
 }
 
 void threadedTimer::store_measurements(LogFile where, sample &samp)
diff --git a/threadedtimer.h b/threadedtimer.h
index 4e402bd..39a3bbd 100644
--- a/threadedtimer.h
+++ b/threadedtimer.h
@@ -10,7 +10,7 @@
 #include "logfile.h"
 
 typedef struct {
-    long long stamp;
+    uint64_t stamp;
     qreal val[4];
 } sample;
 
@@ -39,7 +39,7 @@ public:
     int tcount;
     LogFile testbench_log;
     volatile int curr_queue,sample_batch;
-    sample measurements[4][200];
+    sample measurements[4][800];
     int batch_size[4];
     AnalogDAQ TorqueSensor;
     bool TorqueSensorAvailable;
@@ -47,10 +47,10 @@ public:
     volatile bool start_log,stop_log;
     testbench_states testbench_main_state;
 
-    long long avg_usec;
-    long long start_of_measurements;
-    long long total_amount_of_samples;
-    long long last_measurement;
+    uint64_t avg_usec;
+    uint64_t start_of_measurements;
+    uint64_t total_amount_of_samples;
+    uint64_t last_measurement;
 
 public slots:
     void unit_of_work();
